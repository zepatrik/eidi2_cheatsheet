\documentclass[a4paper,8pt,landscape]{extarticle}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[german]{babel}
\usepackage{parskip}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multicol}
\usepackage[left=1cm,right=1cm,top=1cm,bottom=1cm]{geometry}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{minted}

\usetikzlibrary{calc,positioning,shapes}

\newcommand{\semT}[1]{\llbracket{}\texttt{#1}\rrbracket{}}
\newcommand{\WP}[1]{\textsf{WP}\semT{#1}}
\newcommand{\ocaml}[1]{\mintinline{ocaml}{#1}}

\title{EIDI 2 Cheatsheet}
\author{github contributors: \url{https://github.com/zepatrik/eidi2_cheatsheet} \\
licence CC BY-SA
}

\titlespacing*{\section}{0cm}{0cm}{0cm}
\titlespacing*{\subsection}{0cm}{0cm}{0cm}
\titlespacing*{\paragraph}{0cm}{0cm}{0cm}
\setlength{\itemsep}{1pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}

\begin{document}
  \maketitle
  \newpage
  
  \begin{multicols*}{3}
    \section{Logik}
    \begin{align*}
      \neg (A \lor B) &\equiv \neg A \land B \\
      A \lor (B \land A) &\equiv A \land (B \lor A) \equiv A \\
      A \implies B &\equiv \neg A \lor B
    \end{align*}
    
    \section{Verifikation}
    \subsection{WP}
    \begin{align*}
      \WP{x = read();}(B) &\equiv \forall x.B \\
      I \Rightarrow \WP{b}(B_0, B_1) &\equiv I \Rightarrow (((\neg b) \Rightarrow B_0) \land (b \Rightarrow B_1)) \\
      \WP{b}(B_0, B_1) &\equiv (b \lor B_0) \land (\neg b \lor B_1) \\
      &\equiv (\neg b \land B_0) \lor (b \land B_1) \lor (B_0 \land B_1) \\
      &\equiv (\neg b \land B_0) \lor (b \land B_1)
    \end{align*}
    \subsection{Terminierung}
    \begin{enumerate}
      \item vor jedem Schleifendurchlauf \texttt{r > 0}
      \item \texttt{r} wird bei jedem Durchlauf kleiner
    \end{enumerate}
    
    \begin{tikzpicture}[
    node distance=2em,
    font=\ttfamily,
    rect/.style={rectangle,draw},
    diam/.style={diamond,draw,aspect=2}
    ]
      \node[rect] (1) {r = x + y;};
      \node[above=of 1,yshift=-1em] (0) {};
      \node[diam,below=of 1] (2) {x != y};
      \node[rect,right=of 2] (3) {assert(y > 0);};
      \node[diam,below=of 3] (4) {x < y};
      \node[rect,below left=of 4] (5) {x = x - y;};
      \node[rect,below right=of 4] (6) {y = y - x;};
      \node[rect,below=of 4,yshift=-1.75em] (7) {assert(y > \textcolor{blue}{x + y});};
      \node[rect,below=of 7] (8) {y = \textcolor{blue}{x + y};};
      \node[left=of 2,xshift=1em] (exit) {};
      
      \draw[->] (0) edge (1) (1) edge (2) (3) edge (4) (7) edge (8);
      \path[draw,->] (4) -| node[above] {no} (5) (4) -| node [above] {yes} (6) (2) -- node [above] {yes} (3) (2) -- node[above] {no} (exit);
      \draw[->,to path={|- (\tikztotarget)}] (5) edge (7) (6) edge (7);
      \path[draw,->] (8) -| (2);
    \end{tikzpicture}
    
    \section{ocaml}
    \subsection{Funktoren}
    \begin{minted}{ocaml}
module type A = sig
  type t
  val f : t -> t
end

module B: A = struct
  type t = int
  let f x = x + 1
end

module Ext(X: A) = struct
  include X
  let g x = f (f x)
end

module C = Ext (B)
    \end{minted}
    \subsection{Threaded tree Beispiel}
    \begin{minted}{ocaml}
open Thread open Event

let rec min = function
  | Leaf a -> a
  | Node (a,b) ->
    let c = new_channel () in
    let f t = sync (send c (min t)) in
    let _ = create f a in
    let _ = create f b in
    let x = sync (receive c) in
    let y = sync (receive c) in
    if x < y then x else y
    \end{minted}
    \subsection{Exceptions}
    \begin{minted}{ocaml}
type t = exn

try (
  raise Failure "this should fail"
) with Failure s -> print_string s

exeption Custom of int
try (
  raise Custom 0
) with _ -> ()
    \end{minted}
    \subsection{Invarianten Tipps}
    \begin{enumerate}
     \item Wir benötigen eine Aussage über den Wert der Variablen, über die
wir etwas beweisen wollen (x) in der Schleifeninvariante. Die
Aussage muss dabei mindestens so präzise ($\neq, \geq, \leq, =$) sein, wie
die Aussage, die wir beweisen wollen.
      \item Variablen, die an der Berechnung von x beteiligt sind \textbf{und} Werte
von einer Schleifeniteration in die nächste transportieren
(“loop-carried”), müssen in die Schleifeninvariante aufgenommen
werden.
      \item Die Schleife zu verstehen ist unerlässlich. Eine Tabelle für einige
Schleifendurchläufe kann helfen die Zusammenhänge der Variablen
(insbesondere mit dem Schleifenzähler $i$) aufzudecken. Oft lassen
sich mit einer Tabelle, in der man die einzelnen
Berechnungsschritte notiert, diese Zusammenhänge deutlich
leichter erkennen, als mit einer Tabelle, die nur konkrete Werte
enthält.
      \item Die Variablen, die zur Berechnung von $x$ im Beweisziel verwendet
werden und diejenigen, die dazu in der Invariante verwendet
werden, müssen in Beziehung stehen. Wenn diese Beziehung nicht
aus der Verzweigungsbedingung folgt, müssen weitere Aussagen
zur Invariante hinzugefügt werden.
      \item Bei einer Bedingung mit Ungleichung ($<, \leq, >, \geq$) kann der
Schleifenzähler ($i$) von der anderen Seite ($\geq, \leq$) begrenzt werden,
sodass am Ende der Schleife Gleichheit folgt. Natürlich darf das
nur dann geschehen, wenn diese Begrenzung im Programm auch
tatsächlich gilt.
      \item Werden Programmeingaben begrenzt, z.B. durch Ziehen von
Beträgen, vorzeitigen Programmabbruch bei unerwünschten
Eingaben oder durch gegebene Zusicherungen, so kann die
Information über die Werte der Eingabevariablen ($n, m, ...$), die
innerhalb der Schleife zulässig sind, in der Invariante sinnvoll sein.
      \item Existiert kein klassischer Schleifenzähler, kann ein gedanklicher
Zähler verwendet werden um den Zusammenhang zwischen den
Variablen herzustellen.
      \item Sind in der Schleife Verzweigungen enthalten, so hängt $x$, neben
dem Schleifenzähler, meist auch von einer Variablen ab, die in der
Bedingung der Verzweigung vorkommt. In der Invariante muss
diese Abhängigkeit dann aufgenommen werden. Lässt sich keine
“einfache” Beziehung finden, so kann in der Invariante eine
Fallunterscheidung verwendet werden.
      \item In einem Terminierungsbeweis wird eine Aussage über $r$ in der
Invariante benötigt. Es gilt dabei immer die für $r$ ermittelte
Berechnungsvorschrift.
      \item Für die Terminierung benötigen wir Aussagen über alle Variablen in
der Invarianten, die für die Berechnung von $r$ benötigt werden und
über die sich keine starken Beziehungen aus der Schleifenbedingung
folgern lassen (wobei “stark” hier mindestens $\leq, \geq$ meint).
    \end{enumerate}

    
  \end{multicols*}
\end{document}
